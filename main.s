;
; File generated by cc65 v 2.16 - Git 18b0aaf
;
	.fopt		compiler,"cc65 v 2.16 - Git 18b0aaf"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_nmi_flag
	.export		_index
	.export		_gamepad_1
	.export		_gamepad_1_old
	.export		_gamepad_1_test
	.export		_gamepad_2
	.export		_gamepad_2_old
	.export		_gamepad_2_test
	.export		_ppu_oam
	.export		_ppu_bg_palette
	.export		_ppu_sprite_palette
	.export		_wait_until_nmi
	.export		_ppu_turn_all_off
	.export		_ppu_turn_all_on
	.export		_ppu_reset_scroll
	.export		_ppu_load_bg_palette
	.export		_ppu_load_sprite_palette
	.export		_ppu_load_sprite_to_oam
	.export		_ppu_clear_oam
	.export		_set_bg_palette
	.export		_set_sprite_palette
	.export		_ppu_draw_background
	.import		_get_controller_input
	.import		_unpack_RLE
	.import		_wait_Vblank
	.export		_n1
	.export		_n2
	.export		_n3
	.export		_n4
	.export		_bg_palette
	.export		_sprite_palette
	.export		_pos_x
	.export		_pos_y
	.export		_main

.segment	"DATA"

_n3:
	.byte	$01
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$11
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$11
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$11
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$11
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$11
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$00
_bg_palette:
	.byte	$12
	.byte	$28
	.byte	$08
	.byte	$01
	.byte	$18
	.byte	$1A
	.byte	$2C
	.byte	$32
	.byte	$12
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$12
	.byte	$00
	.byte	$00
	.byte	$00
_sprite_palette:
	.byte	$26
	.byte	$26
	.byte	$08
	.byte	$01
	.byte	$12
	.byte	$05
	.byte	$03
	.byte	$00
	.byte	$12
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$12
	.byte	$00
	.byte	$00
	.byte	$00

.segment	"RODATA"

_n1:
	.byte	$01
	.byte	$10
	.byte	$01
	.byte	$C1
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$C1
	.byte	$01
	.byte	$00
_n2:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$C9
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$17
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$17
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$17
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$17
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$17
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$53
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$11
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$13
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$15
	.byte	$10
	.byte	$01
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$17
	.byte	$10
	.byte	$01
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$FE
	.byte	$00
	.byte	$01
	.byte	$4E
	.byte	$01
	.byte	$00
_n4:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$01
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$10
	.byte	$01
	.byte	$0F
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$10
	.byte	$01
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$FE
	.byte	$00
	.byte	$01
	.byte	$C0
	.byte	$10
	.byte	$01
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$10
	.byte	$01
	.byte	$0F
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$10
	.byte	$01
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$01
	.byte	$00

.segment	"BSS"

.segment	"ZEROPAGE"
.segment	"OAM"
.segment	"BSS"
.segment	"OAM"
.segment	"ZEROPAGE"
.segment	"OAM"
.segment	"BSS"
.segment	"OAM"
.segment	"ZEROPAGE"
.segment	"ZEROPAGE"
_nmi_flag:
	.res	1,$00
.segment	"ZEROPAGE"
_index:
	.res	1,$00
.segment	"ZEROPAGE"
_gamepad_1:
	.res	1,$00
.segment	"ZEROPAGE"
_gamepad_1_old:
	.res	1,$00
.segment	"ZEROPAGE"
_gamepad_1_test:
	.res	1,$00
.segment	"ZEROPAGE"
_gamepad_2:
	.res	1,$00
.segment	"ZEROPAGE"
_gamepad_2_old:
	.res	1,$00
.segment	"ZEROPAGE"
_gamepad_2_test:
	.res	1,$00
.segment	"OAM"
_ppu_oam:
	.res	256,$00
.segment	"BSS"
_ppu_bg_palette:
	.res	16,$00
.segment	"BSS"
_ppu_sprite_palette:
	.res	16,$00
.segment	"ZEROPAGE"
_pos_x:
	.res	1,$00
.segment	"ZEROPAGE"
_pos_y:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ wait_until_nmi (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_wait_until_nmi: near

.segment	"CODE"

;
; while(nmi_flag == 0);
;
L0430:	lda     _nmi_flag
	beq     L0430
;
; nmi_flag = 0;
;
	lda     #$00
	sta     _nmi_flag
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_turn_all_off (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_turn_all_off: near

.segment	"CODE"

;
; PPU_CTRL = 0; /* binary 00000000 - all disabled */
;
	lda     #$00
	sta     $2000
;
; PPU_MASK = 0;  /* binary 00000000 - all disabled */
;
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_turn_all_on (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_turn_all_on: near

.segment	"CODE"

;
; bit 4: turn on screen */
;
	lda     #$90
	sta     $2000
;
; bit 1: show background in leftmost 8 pixels on screen */
;
	lda     #$1E
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_reset_scroll (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_reset_scroll: near

.segment	"CODE"

;
; PPU_ADDRESS = 0; /* set high byte to 0 */
;
	lda     #$00
	sta     $2006
;
; PPU_ADDRESS = 0; /* set low byte to 0 */
;
	sta     $2006
;
; PPU_SCROLL = 0;  /* set scroll x_position to 0 */
;
	sta     $2005
;
; PPU_SCROLL = 0;  /* set scroll y_position to 0 */
;
	sta     $2005
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_load_bg_palette (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_load_bg_palette: near

.segment	"CODE"

;
; PPU_ADDRESS = MSB(0x3f00);
;
	lda     #$3F
	sta     $2006
;
; PPU_ADDRESS = LSB(0x3f00);
;
	lda     #$00
	sta     $2006
;
; for (index = 0; index < sizeof(ppu_bg_palette); ++index) {
;
	sta     _index
L0431:	lda     _index
	cmp     #$10
	bcs     L003F
;
; PPU_DATA = ppu_bg_palette[index];
;
	ldy     _index
	lda     _ppu_bg_palette,y
	sta     $2007
;
; for (index = 0; index < sizeof(ppu_bg_palette); ++index) {
;
	inc     _index
	jmp     L0431
;
; }
;
L003F:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_load_sprite_palette (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_load_sprite_palette: near

.segment	"CODE"

;
; for(index = 0; index < sizeof(ppu_sprite_palette); ++index){
;
	lda     #$00
	sta     _index
L0432:	lda     _index
	cmp     #$10
	bcs     L004E
;
; if(index == 0){
;
	lda     _index
	bne     L0433
;
; PPU_ADDRESS = MSB(0x3f11);
;
	lda     #$3F
	sta     $2006
;
; PPU_ADDRESS = LSB(0x3f11);
;
	lda     #$11
	sta     $2006
;
; continue;
;
	jmp     L0436
;
; if(index == 4){
;
L0433:	lda     _index
	cmp     #$04
	bne     L0434
;
; PPU_ADDRESS = MSB(0x3f15);
;
	lda     #$3F
	sta     $2006
;
; PPU_ADDRESS = LSB(0x3f15);
;
	lda     #$15
	sta     $2006
;
; continue;
;
	jmp     L0436
;
; if(index == 8){
;
L0434:	lda     _index
	cmp     #$08
	bne     L0435
;
; PPU_ADDRESS = MSB(0x3f19);
;
	lda     #$3F
	sta     $2006
;
; PPU_ADDRESS = LSB(0x3f19);
;
	lda     #$19
	sta     $2006
;
; continue;
;
	jmp     L0436
;
; if(index == 12){
;
L0435:	lda     _index
	cmp     #$0C
	bne     L0080
;
; PPU_ADDRESS = MSB(0x3f1d);
;
	lda     #$3F
	sta     $2006
;
; PPU_ADDRESS = LSB(0x3f1d);
;
	lda     #$1D
	sta     $2006
;
; continue;
;
	jmp     L0436
;
; PPU_DATA = ppu_sprite_palette[index];
;
L0080:	ldy     _index
	lda     _ppu_sprite_palette,y
	sta     $2007
;
; for(index = 0; index < sizeof(ppu_sprite_palette); ++index){
;
L0436:	inc     _index
	jmp     L0432
;
; }
;
L004E:	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ ppu_load_sprite_to_oam (unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_load_sprite_to_oam: near

.segment	"CODE"

;
; unsigned char ppu_load_sprite_to_oam(unsigned char x, unsigned char y, unsigned char tile, unsigned char attribute, unsigned char offset){
;
	jsr     pusha
;
; ppu_oam[offset] = y;
;
	ldy     #$00
	lda     (sp),y
	tax
	ldy     #$03
	lda     (sp),y
	sta     _ppu_oam,x
;
; ppu_oam[++offset] = tile;
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
	clc
	adc     #<(_ppu_oam)
	sta     ptr1
	tya
	adc     #>(_ppu_oam)
	sta     ptr1+1
	ldy     #$02
	lda     (sp),y
	ldy     #$00
	sta     (ptr1),y
;
; ppu_oam[++offset] = attribute;
;
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
	clc
	adc     #<(_ppu_oam)
	sta     ptr1
	tya
	adc     #>(_ppu_oam)
	sta     ptr1+1
	iny
	lda     (sp),y
	dey
	sta     (ptr1),y
;
; ppu_oam[++offset] = x;
;
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
	clc
	adc     #<(_ppu_oam)
	sta     ptr1
	tya
	adc     #>(_ppu_oam)
	sta     ptr1+1
	ldy     #$04
	lda     (sp),y
	ldy     #$00
	sta     (ptr1),y
;
; return ++offset;
;
	ldx     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; }
;
	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_clear_oam (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_clear_oam: near

.segment	"CODE"

;
; for(index = 0; index < sizeof(ppu_oam); ++index){
;
	lda     #$00
	sta     _index
;
; ppu_oam[index] = 0x00;
;
L00A6:	ldy     _index
	sta     _ppu_oam,y
;
; for(index = 0; index < sizeof(ppu_oam); ++index){
;
	inc     _index
	jmp     L00A6

.endproc

; ---------------------------------------------------------------
; void __near__ set_bg_palette (__near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_set_bg_palette: near

.segment	"CODE"

;
; void set_bg_palette(unsigned char *bg_palette){
;
	jsr     pushax
;
; for(index = 0; index < sizeof(ppu_bg_palette); ++index){
;
	lda     #$00
	sta     _index
L0439:	lda     _index
	cmp     #$10
	bcs     L00B2
;
; ppu_bg_palette[index] = *bg_palette + index;
;
	lda     #<(_ppu_bg_palette)
	ldx     #>(_ppu_bg_palette)
	clc
	adc     _index
	bcc     L00BC
	inx
L00BC:	sta     sreg
	stx     sreg+1
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	clc
	adc     _index
	sta     (sreg),y
;
; for(index = 0; index < sizeof(ppu_bg_palette); ++index){
;
	inc     _index
	jmp     L0439
;
; }
;
L00B2:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ set_sprite_palette (__near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_set_sprite_palette: near

.segment	"CODE"

;
; void set_sprite_palette(unsigned char *sprite_palette){
;
	jsr     pushax
;
; for(index = 0; index < sizeof(ppu_sprite_palette); ++index){
;
	lda     #$00
	sta     _index
L043B:	lda     _index
	cmp     #$10
	bcs     L00C0
;
; ppu_sprite_palette[index] = *sprite_palette + index;
;
	lda     #<(_ppu_sprite_palette)
	ldx     #>(_ppu_sprite_palette)
	clc
	adc     _index
	bcc     L00CA
	inx
L00CA:	sta     sreg
	stx     sreg+1
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	clc
	adc     _index
	sta     (sreg),y
;
; for(index = 0; index < sizeof(ppu_sprite_palette); ++index){
;
	inc     _index
	jmp     L043B
;
; }
;
L00C0:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_draw_background (__near__ unsigned char *, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_draw_background: near

.segment	"CODE"

;
; void ppu_draw_background(unsigned char *bg, unsigned char nametable){
;
	jsr     pusha
;
; switch(nametable){
;
	ldy     #$00
	lda     (sp),y
;
; }
;
	cmp     #$61
	beq     L0441
	cmp     #$62
	beq     L0441
	cmp     #$63
	beq     L0441
	cmp     #$64
;
; default : PPU_ADDRESS = MSB(NAMETABLE_A) ; PPU_ADDRESS = LSB(NAMETABLE_A);
;
L0441:	lda     #$20
	sta     $2006
	sty     $2006
;
; unpack_RLE(bg);
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _unpack_RLE
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; ppu_turn_all_off();
;
	jsr     _ppu_turn_all_off
;
; set_bg_palette(bg_palette);
;
	lda     #<(_bg_palette)
	ldx     #>(_bg_palette)
	jsr     _set_bg_palette
;
; set_sprite_palette(sprite_palette);
;
	lda     #<(_sprite_palette)
	ldx     #>(_sprite_palette)
	jsr     _set_sprite_palette
;
; ppu_load_bg_palette();
;
	jsr     _ppu_load_bg_palette
;
; ppu_load_sprite_palette();
;
	jsr     _ppu_load_sprite_palette
;
; ppu_draw_background(n3, 'a');
;
	lda     #<(_n3)
	ldx     #>(_n3)
	jsr     pushax
	lda     #$61
	jsr     _ppu_draw_background
;
; wait_Vblank();
;
	jsr     _wait_Vblank
;
; ppu_turn_all_on();
;
	jsr     _ppu_turn_all_on
;
; pos_x = 0x20;
;
	lda     #$20
	sta     _pos_x
;
; pos_y = 0x20;
;
	sta     _pos_y
;
; wait_until_nmi();
;
L0407:	jsr     _wait_until_nmi
;
; OAM_ADDRESS = 0;
;
	lda     #$00
	sta     $2003
;
; OAM_DMA = 2; // push all the sprite data from the ram at 200-2ff to the sprite memory
;
	lda     #$02
	sta     $4014
;
; PPU_CTRL = 0x90; // screen is on, NMIs on
;
	lda     #$90
	sta     $2000
;
; PPU_MASK = 0x1e;
;
	lda     #$1E
	sta     $2001
;
; ppu_reset_scroll();
;
	jsr     _ppu_reset_scroll
;
; ppu_load_sprite_to_oam(pos_x,pos_y,0x01,SPRITE_ATTR(0,0,0,0),0);
;
	jsr     decsp4
	lda     _pos_x
	ldy     #$03
	sta     (sp),y
	lda     _pos_y
	dey
	sta     (sp),y
	lda     #$01
	dey
	sta     (sp),y
	lda     #$00
	dey
	sta     (sp),y
	jsr     _ppu_load_sprite_to_oam
;
; if(gamepad_1&DIR_DOWN){
;
	lda     _gamepad_1
	and     #$04
	beq     L0444
;
; ++pos_y;
;
	inc     _pos_y
;
; if(gamepad_1&DIR_UP){
;
L0444:	lda     _gamepad_1
	and     #$08
	beq     L0445
;
; --pos_y;
;
	dec     _pos_y
;
; if(gamepad_1&DIR_LEFT){
;
L0445:	lda     _gamepad_1
	and     #$02
	beq     L0446
;
; --pos_x;
;
	dec     _pos_x
;
; if(gamepad_1&DIR_RIGHT){
;
L0446:	lda     _gamepad_1
	and     #$01
	beq     L042C
;
; ++pos_x;
;
	inc     _pos_x
;
; get_controller_input();
;
L042C:	jsr     _get_controller_input
;
; while(1){
;
	jmp     L0407

.endproc

